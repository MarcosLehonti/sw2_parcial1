{% extends "base.html" %}

{% block title %}Resultados Â· EscÃ¡ner{% endblock %}
{% block hero_title %}Resultados del Escaneo{% endblock %}
{% block hero_subtitle %}Resumen y detalle por vulnerabilidad{% endblock %}

{% block alerts %}
  {% with messages = get_flashed_messages(with_categories=true) %}
    {% if messages %}
      {% for category, message in messages %}
        <div class="alert alert-{{ category }} alert-dismissible fade show" role="alert">
          {{ message }}
          <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
        </div>
      {% endfor %}
    {% endif %}
  {% endwith %}
{% endblock %}

{% block content %}
  <!-- Barra superior -->
  <div class="result-bar d-flex align-items-center justify-content-between p-3 rounded-3 shadow-sm mb-4">
    <div class="d-flex align-items-center gap-3">
      <span class="badge url-badge"><i class="fas fa-link me-1"></i> {{ scanned_url|default('', true) }}</span>
      <small class="text-muted d-none d-md-inline">Fecha: {{ scan_time|default('', true) }}</small>
    </div>
    <div class="d-flex gap-2">
      <a href="{{ url_for('index') }}" class="btn btn-outline-dark rounded-pill">
        <i class="fas fa-arrow-left me-1"></i> Volver al inicio
      </a>
      <button class="btn btn-gradient rounded-pill" onclick="window.print()">
        <i class="fas fa-print me-1"></i> Imprimir
      </button>
    </div>
  </div>

  <!-- Consola -->
  <div class="card shadow mb-4">
    <div class="card-header d-flex justify-content-between align-items-center">
      <h3 class="mb-0">Consola de Escaneo</h3>
      <div class="scan-status text-center" id="scanStatusContainer">
        <div class="spinner-border text-primary" role="status" id="scanSpinner">
          <span class="visually-hidden">Cargando...</span>
        </div>
        <p class="mt-2 mb-0" id="scanStatus">Escaneo en progreso...</p>
      </div>
    </div>
    <div class="card-body">
      <div class="console-output" id="consoleOutput">
        <div class="console-line">Inicializando escaneo...</div>
      </div>
    </div>
  </div>

  <!-- Resumen/Tabla -->
  <table class="table table-striped table-hover vuln-table">
    <div class="card shadow mb-4 hidden" id="resultsCard">
      <div class="card-header bg-light">
        <h3 class="mb-0 text-center">Resumen de Vulnerabilidades</h3>
      </div>
      <div class="card-body">
        <div class="table-responsive">
          <table class="table table-striped table-hover">
            <thead class="table-dark">
              <tr>
                <th>Vulnerabilidad</th>
                <th>Estado</th>
                <th>Nivel de Riesgo</th>
              </tr>
            </thead>
            <tbody id="resultsTable"></tbody>
          </table>
        </div>

        <div class="text-center mt-4">
          <a href="{{ url_for('download_report', session_id=session_id) }}" class="btn btn-success btn-lg" id="downloadBtn" disabled>
            <i class="fas fa-file-pdf me-2"></i> Descargar Reporte PDF
          </a>

          <a href="{{ url_for('download_correcciones', session_id=session_id) }}" 
            class="btn btn-warning btn-lg ms-2" 
            id="downloadCorreccionesBtn" disabled>
            <i class="fas fa-tools me-2"></i> Descargar Correcciones PDF
          </a>
        </div>
      </div>
    </div>
  </table>

  <!-- ðŸ”¹ Card para correcciones -->
  <div class="card shadow mb-4 hidden" id="correccionesCard">
    <div class="card-header bg-light">
      <h3 class="mb-0 text-center">Correcciones sugeridas</h3>
    </div>
    <div class="card-body">
      <ul id="correccionesList" class="list-group"></ul>
    </div>
  </div>
{% endblock %}

{% block scripts %}
<script>
  document.addEventListener('DOMContentLoaded', function() {
    const consoleOutput = document.getElementById('consoleOutput');
    const resultsTable = document.getElementById('resultsTable');
    const resultsCard = document.getElementById('resultsCard');
    const downloadBtn = document.getElementById('downloadBtn');
    const scanSpinner = document.getElementById('scanSpinner');
    const scanStatus = document.getElementById('scanStatus');
    const correccionesCard = document.getElementById('correccionesCard');
    const correccionesList = document.getElementById('correccionesList');

    let scanComplete = false;
    const results = {};

    // Variables para detectar y acumular bloque JSON de correcciones (incluso si llega dividido)
    let inCorreccionesBlock = false;
    let correccionesBuffer = '';
    let squareCount = 0;
    let curlyCount = 0;
    let parsedCorrecciones = null; // aquÃ­ guardamos correcciones si logramos parsear antes de `data.complete`

    function countOcc(str, char) {
      return (str.match(new RegExp('\\' + char, 'g')) || []).length;
    }

    function tryParseCorreccionesBuffer() {
      if (!correccionesBuffer.trim()) {
        // nothing to parse
        inCorreccionesBlock = false;
        correccionesBuffer = '';
        squareCount = curlyCount = 0;
        return;
      }

      // Intentar parseo directo
      try {
        const attempt = correccionesBuffer.trim();
        // Buscar el primer '[' y el Ãºltimo ']' para recortar si hay texto extra alrededor
        const firstBracket = attempt.indexOf('[');
        const lastBracket = attempt.lastIndexOf(']');
        let candidate = attempt;
        if (firstBracket !== -1 && lastBracket !== -1 && lastBracket > firstBracket) {
          candidate = attempt.substring(firstBracket, lastBracket + 1);
        }
        const parsed = JSON.parse(candidate);
        if (Array.isArray(parsed)) {
          parsedCorrecciones = parsed;
        } else {
          // si viene como objeto que contiene la lista
          if (parsed && Array.isArray(parsed.correcciones)) parsedCorrecciones = parsed.correcciones;
          else parsedCorrecciones = null;
        }
      } catch (e) {
        console.error('No se pudo parsear correcciones (intento):', e);
        // dejar parsedCorrecciones = null; (podrÃ­amos intentar mÃ¡s heurÃ­sticas si hace falta)
      } finally {
        // reset buffer
        inCorreccionesBlock = false;
        correccionesBuffer = '';
        squareCount = curlyCount = 0;
      }

      // Si logramos parsear, renderizamos inmediatamente (no esperar al complete)
      if (parsedCorrecciones && parsedCorrecciones.length) {
        renderCorrecciones(parsedCorrecciones);
      }
    }

    function renderCorrecciones(correccionesArray) {
      if (!Array.isArray(correccionesArray) || correccionesArray.length === 0) return;
      correccionesCard.classList.remove('hidden');
      correccionesList.innerHTML = '';

      correccionesArray.forEach(c => {
        const vulnContainer = document.createElement('div');
        vulnContainer.className = "vulnerability-container mb-3 p-2 border rounded";

        // TÃ­tulo: vulnerabilidad - riesgo
        const header = document.createElement('h5');
        const vulnName = c.vulnerabilidad || c.nombre || 'Vulnerabilidad';
        const riesgo = c.riesgo || c.risk || '';
        header.textContent = vulnName + (riesgo ? ' â€” ' + riesgo : '');
        vulnContainer.appendChild(header);

        // Mostrar correcciones completas (lista ordenada)
        const stepsList = document.createElement('ol');
        const pasos = Array.isArray(c.correcciones) ? c.correcciones : (typeof c.correcciones === 'string' ? [c.correcciones] : []);
        pasos.forEach(paso => {
          const li = document.createElement('li');
          li.textContent = paso;
          stepsList.appendChild(li);
        });

        // Si no hay pasos pero la entrada es un texto grande, mostrar el texto completo en <pre>
        if (pasos.length === 0 && c.texto) {
          const pre = document.createElement('pre');
          pre.textContent = c.texto;
          vulnContainer.appendChild(pre);
        } else {
          vulnContainer.appendChild(stepsList);
        }

        correccionesList.appendChild(vulnContainer);
      });
    }

    function getResults() {
      fetch('{{ url_for("get_results") }}')
      .then(response => response.json())
      .then(data => {
        // data.results puede contener lÃ­neas normales y tambiÃ©n bloques JSON (con o sin ```json fences).
        (data.results || []).forEach(message => {
          const trimmed = (message || '').trim();

          // Detectores de inicio de bloque de correcciones / JSON
          const looksLikeStartFence = trimmed.toLowerCase().startsWith('```json') || trimmed.toLowerCase().startsWith('```');
          const looksLikeCorreccionesKeyword = trimmed.toLowerCase().includes('correcciones') || trimmed.toLowerCase().includes('"vulnerabilidad"') || trimmed.toLowerCase().includes('"correcciones"') || trimmed.toLowerCase().includes('"riesgo"');
          const looksLikeJsonArrayStart = trimmed.startsWith('[') || trimmed.startsWith('{');

          // Si NO estamos dentro de un bloque y el mensaje parece pertenecer a correcciones / JSON -> comenzar a acumular
          if (!inCorreccionesBlock && (looksLikeStartFence || looksLikeCorreccionesKeyword || looksLikeJsonArrayStart)) {
            inCorreccionesBlock = true;
            // limpiamos code fences y encabezados tipo '--- Correcciones sugeridas ---'
            let cleaned = message.replace(/```json/gi, '').replace(/```/g, '').replace(/---\s*Correcciones sugeridas\s*---/gi, '').trim();
            if (cleaned) {
              correccionesBuffer += cleaned + '\n';
              squareCount += countOcc(cleaned, '[') - countOcc(cleaned, ']');
              curlyCount += countOcc(cleaned, '{') - countOcc(cleaned, '}');
            }
            // Si el bloque queda balanceado en esta misma lÃ­nea, intentamos parsear
            if (squareCount === 0 && curlyCount === 0) tryParseCorreccionesBuffer();
            // NO agregar a consola
            return;
          }

          // Si ya estamos dentro de un bloque de correcciones, acumulamos hasta que estÃ© balanceado
          if (inCorreccionesBlock) {
            let cleaned = message.replace(/```json/gi, '').replace(/```/g, '').trim();
            if (cleaned) {
              correccionesBuffer += cleaned + '\n';
              squareCount += countOcc(cleaned, '[') - countOcc(cleaned, ']');
              curlyCount += countOcc(cleaned, '{') - countOcc(cleaned, '}');
            }
            if (squareCount === 0 && curlyCount === 0) {
              tryParseCorreccionesBuffer();
            }
            // NO agregar este fragmento a la consola
            return;
          }

          // Si llegamos aquÃ­ => no es bloque de correcciones, lo mostramos en consola
          addConsoleMessage(message);

          // Intentamos extraer vulnerabilidad, estado y riesgo con regex
          const match = message.match(/^(.*?): (.*?) \(Risk: (.*?)\)$/);
          if (match) {
            const [, vulnerability, status, risk] = match;
            results[vulnerability] = { status, risk };
          }
        });

        // Si el backend ademÃ¡s envÃ­a data.correcciones (separado), lo procesamos con prioridad
        if (data.correcciones) {
          let correcciones = data.correcciones;

          if (typeof correcciones === "string") {
            try {
              correcciones = correcciones.replace(/```json/gi, "").replace(/```/g, "").trim();
              // extraer la primera lista JSON vÃ¡lida si hay texto extra
              const firstBracket = correcciones.indexOf('[');
              const lastBracket = correcciones.lastIndexOf(']');
              if (firstBracket !== -1 && lastBracket !== -1 && lastBracket > firstBracket) {
                correcciones = correcciones.substring(firstBracket, lastBracket + 1);
              }
              correcciones = JSON.parse(correcciones);
            } catch (e) {
              console.error("Error al parsear data.correcciones:", e);
              correcciones = null;
            }
          }

          if (Array.isArray(correcciones)) {
            parsedCorrecciones = correcciones;
            renderCorrecciones(parsedCorrecciones);
          }
        }

        // Si el scan terminÃ³ -> mostrar tabla y estado
        if (data.complete && !scanComplete) {
          scanComplete = true;
          updateResultsTable();
          resultsCard.classList.remove('hidden');
          downloadBtn.removeAttribute('disabled');
          scanSpinner.classList.add('hidden');
          scanStatus.textContent = 'Escaneo completado';
          scanStatus.classList.add('text-success');

          // Si aÃºn no parseamos correcciones desde data.correcciones pero ya tenemos parsedCorrecciones (acumulado), mostrarlo
          if (!parsedCorrecciones && data.correcciones) {
            // (ya intentamos parsear arriba)
          }

          if (!parsedCorrecciones && correccionesBuffer.trim()) {
            // Si por alguna razÃ³n quedÃ³ algo en el buffer, intentar parsearlo ahora
            tryParseCorreccionesBuffer();
          }
        } else if (!scanComplete) {
          // seguir preguntando
          setTimeout(getResults, 1000);
        }
      })
      .catch(error => {
        console.error('Error:', error);
        addConsoleMessage('Error en la comunicaciÃ³n con el servidor: ' + (error.message || error));
        setTimeout(getResults, 2000);
      });
    }

    function addConsoleMessage(message) {
      const lineElement = document.createElement('div');
      lineElement.className = 'console-line';
      if (message.includes('(Risk: High)')) {
        lineElement.classList.add('risk-high');
      } else if (message.includes('(Risk: Medium)')) {
        lineElement.classList.add('risk-medium');
      } else if (message.includes('(Risk: Low)')) {
        lineElement.classList.add('risk-low');
      } else if (message.includes('(Risk: Unknown)')) {
        lineElement.classList.add('risk-unknown');
      }
      lineElement.textContent = message;
      consoleOutput.appendChild(lineElement);
      consoleOutput.scrollTop = consoleOutput.scrollHeight;
    }

    function updateResultsTable() {
      resultsTable.innerHTML = '';
      for (const [vulnerability, { status, risk }] of Object.entries(results)) {
        const row = document.createElement('tr');

        const vulnCell = document.createElement('td');
        vulnCell.textContent = vulnerability;
        row.appendChild(vulnCell);

        const statusCell = document.createElement('td');
        statusCell.textContent = status;
        row.appendChild(statusCell);

        const riskCell = document.createElement('td');
        riskCell.textContent = risk;
        if (risk === 'High') riskCell.className = 'risk-high';
        else if (risk === 'Medium') riskCell.className = 'risk-medium';
        else if (risk === 'Low') riskCell.className = 'risk-low';
        else riskCell.className = 'risk-unknown';

        row.appendChild(riskCell);
        resultsTable.appendChild(row);
      }
    }

    // arrancamos
    setTimeout(getResults, 1000);
  });
</script>
{% endblock %}
